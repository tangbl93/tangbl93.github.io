<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.0">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Docusaurus Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Docusaurus Blog Atom Feed"><title data-react-helmet="true">Dart tour: 9、类 | Docusaurus</title><meta data-react-helmet="true" property="og:url" content="https://tangbl93.github.io//docs/dart/dart-tour-classes"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Dart tour: 9、类 | Docusaurus"><meta data-react-helmet="true" name="description" content="Dart 是支持基于 mixin 继承机制的面向对象语言，所有对象都是一个类的实例，而除了 Null 以外的所有的类都继承自 Object 类。基于 mixin 的继承扩展是一种在不更改类或创建子类的情况下向类添加功能的方式。"><meta data-react-helmet="true" property="og:description" content="Dart 是支持基于 mixin 继承机制的面向对象语言，所有对象都是一个类的实例，而除了 Null 以外的所有的类都继承自 Object 类。基于 mixin 的继承扩展是一种在不更改类或创建子类的情况下向类添加功能的方式。"><link data-react-helmet="true" rel="shortcut icon" href="/images/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://tangbl93.github.io//docs/dart/dart-tour-classes"><link data-react-helmet="true" rel="alternate" href="https://tangbl93.github.io//docs/dart/dart-tour-classes" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://tangbl93.github.io//docs/dart/dart-tour-classes" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.dc5e9681.css">
<link rel="preload" href="/assets/js/runtime~main.d5afd100.js" as="script">
<link rel="preload" href="/assets/js/main.c75862fc.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/images/logo.svg" alt="Docusaurus Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/images/logo.svg" alt="Docusaurus Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><strong class="navbar__title">Docusaurus</strong></a><a class="navbar__item navbar__link navbar__link--active" href="/docs/index">专栏</a><a class="navbar__item navbar__link" href="/blog">博客</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/tangbl93/tangbl93.github.io" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--disabled" role="button" tabindex="-1"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><img src="/images/logo.svg" alt="Docusaurus Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/images/logo.svg" alt="Docusaurus Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><strong class="navbar__title">Docusaurus</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link navbar__link--active" href="/docs/index">专栏</a></li><li class="menu__list-item"><a class="menu__link" href="/blog">博客</a></li><li class="menu__list-item"><a href="https://github.com/tangbl93/tangbl93.github.io" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><div class="docSidebarContainer_3Kbt" role="complementary"><div class="sidebar_15mo"><div class="menu menu--responsive thin-scrollbar menu_Bmed"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/index">专栏</a></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">Dart tour</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/dart/dart-tour-preface">Dart tour: 1、概览</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/dart/dart-tour-comments">Dart tour: 2、注释</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/dart/dart-tour-variables">Dart tour: 3、变量</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/dart/dart-tour-types">Dart tour: 4、数据类型</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/dart/dart-tour-functions">Dart tour: 5、函数</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/dart/dart-tour-operators">Dart tour: 6、操作符</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/dart/dart-tour-control">Dart tour: 7、控制流程语句</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/dart/dart-tour-exceptions">Dart tour: 8、异常</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/docs/dart/dart-tour-classes">Dart tour: 9、类</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/dart/dart-tour-enums">Dart tour: 10、枚举</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/dart/dart-tour-mixin">Dart tour: 11、Mixin</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/dart/dart-tour-generics">Dart tour: 12、泛型</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/dart/dart-tour-libraries">Dart tour: 13、使用库</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/dart/dart-tour-asynchrony">Dart tour: 14、异步编程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/dart/dart-tour-generators">Dart tour: 15、生成器</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/dart/dart-tour-isolates">Dart tour: 16、隔离区(Isolates)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/dart/dart-tour-typedef">Dart tour: 17、Typedefs</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/dart/dart-tour-metadata">Dart tour: 18、Metadata</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/dart/dart-tour-null-safety">Dart tour: 19、Sound null safety</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/dart/dart-tour-package">Dart tour: 20、Package</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Fastlane实战</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/fastlane/index">0、前言</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/fastlane/fastlane-gym-01">1、自动化打包(上)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/fastlane/fastlane-gym-02">2、自动化打包(下)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/fastlane/fastlane-match">3、管理证书</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/fastlane/fastlane-tjcsj">4、添加测试机</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/fastlane/fastlane-iap">5、新建内购项目</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/fastlane/fastlane-archive">6、通过Archive生成IPA</a></li></ul></li></ul></div></div></div><main class="docMainContainer_3ufF"><div class="container padding-vert--lg docItemWrapper_3FMP"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><header><h1 class="docTitle_3a4h">Dart tour: 9、类</h1></header><div class="markdown"><blockquote><p><code>Dart</code> 是支持基于 <code>mixin</code> 继承机制的面向对象语言，所有对象都是一个类的实例，而除了 Null 以外的所有的类都继承自 Object 类。基于 <code>mixin</code> 的继承扩展是一种在不更改类或创建子类的情况下向类添加功能的方式。</p></blockquote><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="类的成员"></a>类的成员<a class="hash-link" href="#类的成员" title="Direct link to heading">#</a></h2><p>对象的成员由函数和数据（即方法和实例变量）组成。方法的调用要通过对象来完成，这种方式可以访问对象的函数和数据。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly dart"><div tabindex="0" class="prism-code language-dart codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 使用（.）来访问对象的实例变量或方法</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">var p = Point(2, 2);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">assert(p.y == 2); // 获取 y 值</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 调用变量 p 的 distanceTo() 方法</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">double distance = p.distanceTo(Point(4, 4));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 使用 ?. 代替 . 可以避免因为左边表达式为 null 而导致的问题</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">var a = p?.y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">print(a);</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="实例变量"></a>实例变量<a class="hash-link" href="#实例变量" title="Direct link to heading">#</a></h2><p>未初始化的实例变量其值均为 null, 且实例变量也支持 <code>final</code>、<code>late</code> 等修饰符。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly dart"><div tabindex="0" class="prism-code language-dart codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 声明实例变量案例</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Point {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  double? x;            // null</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  double? y;            // null</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  final double z = 0;   // 0.0</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="构造函数"></a>构造函数<a class="hash-link" href="#构造函数" title="Direct link to heading">#</a></h2><blockquote><p>当且仅当命名冲突时使用 <code>this</code> 关键字才有意义，否则 <code>Dart</code> 会忽略 <code>this</code> 关键字。</p></blockquote><blockquote><p>可以使用构造函数来创建一个对象。从 <code>Dart 2</code> 开始，<code>new</code> 关键字是可选的。</p></blockquote><p>构造函数是一个与类名一样的函数(对于命名式构造函数 还可以添加额外的标识符)，其用于创建一个类的实例。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly dart"><div tabindex="0" class="prism-code language-dart codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 还会有更好的方式来实现此逻辑，敬请期待。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Point {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  double x = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  double y = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Point(double x, double y) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    // 在类中使用 this 关键字引用当前实例</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    this.x = x;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    this.y = y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 在构造函数中为实例变量赋值的过程大多数都是类似的，Dart 提供了语法糖来简化该步骤</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Point {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // 在构造函数体执行前用于设置 x 和 y 的语法糖</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Point(this.x, this.y);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="默认构造函数"></a>默认构造函数<a class="hash-link" href="#默认构造函数" title="Direct link to heading">#</a></h3><p>如果没有声明构造函数，那么 <code>Dart</code> 会自动生成一个<code>无参数的构造函数</code>并且该构造函数会<code>调用其父类的无参数构造方法</code>。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="构造函数不被继承"></a>构造函数不被继承<a class="hash-link" href="#构造函数不被继承" title="Direct link to heading">#</a></h3><p>子类不会继承父类的构造函数，如果子类没有声明构造函数，那么只会有一个默认无参数的构造函数。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="命名式构造函数"></a>命名式构造函数<a class="hash-link" href="#命名式构造函数" title="Direct link to heading">#</a></h3><p>可以为一个类声明多个命名式构造函数来表达更明确的意图：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly dart"><div tabindex="0" class="prism-code language-dart codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Point {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // 命名式构造函数</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Point.origin()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      : x = xOrigin,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        y = yOrigin;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="调用父类非默认构造函数"></a>调用父类非默认构造函数<a class="hash-link" href="#调用父类非默认构造函数" title="Direct link to heading">#</a></h3><blockquote><p>传递给父类构造函数的参数不能使用 <code>this</code> 关键字，因为在参数传递的这一步骤，子类构造函数尚未执行，子类的实例对象也就还未初始化，因此所有的实例成员都不能被访问，但是类成员可以。</p></blockquote><p>默认情况下，子类的构造函数会调用父类的匿名无参构造函数，并且该调用会在子类构造函数的函数体代码执行前，如果子类构造函数还有一个初始化列表，那么该初始化列表会在调用父类的该构造函数之前被执行，总的来说，这三者的调用顺序如下：</p><ol><li>初始化列表</li><li>父类的无参构造函数</li><li>当前类的构造函数</li></ol><p>如果父类没有匿名无参构造函数，那么子类必须调用父类的其中一个构造函数，为子类的构造函数指定一个父类的构造函数需在构造函数体前使用（:）指定。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly dart"><div tabindex="0" class="prism-code language-dart codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Employee 类的构造函数调用了父类 Person 的命名构造函数</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Person {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  String? firstName;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Person.fromJson(Map data) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    print(&#x27;in Person&#x27;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Employee extends Person {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // Person 类没有匿名无参构造函数, 因此必需调用 Person.fromJson 构造函数</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Employee.fromJson(Map data) : super.fromJson(data) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    print(&#x27;in Employee&#x27;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">void main() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  var employee = Employee.fromJson({});</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  print(employee);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // Prints: in Person -&gt;  in Employee -&gt; Instance of &#x27;Employee&#x27;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>因为参数会在子类构造函数被执行前传递给父类的构造函数，因此该参数也可以是一个表达式，比如一个函数。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly dart"><div tabindex="0" class="prism-code language-dart codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Employee extends Person {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Employee() : super.fromJson(fetchDefaultData());</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="初始化列表"></a>初始化列表<a class="hash-link" href="#初始化列表" title="Direct link to heading">#</a></h3><blockquote><p>初始化列表表达式 <code>=</code> 右边的语句不能使用 <code>this</code> 关键字</p></blockquote><p>除了调用父类构造函数之外，还可以在构造函数体执行之前初始化实例变量。每个实例变量之间使用逗号分隔。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly dart"><div tabindex="0" class="prism-code language-dart codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 使用初始化列表在构造函数体执行前设置实例变量。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Point.fromJson(Map&lt;String, double&gt; json)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    : x = json[&#x27;x&#x27;]!,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      y = json[&#x27;y&#x27;]! {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  print(&#x27;In Point.fromJson(): ($x, $y)&#x27;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 在开发模式下，可以在初始化列表中使用 assert 来验证输入数据</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Point.withAssert(this.x, this.y) : assert(x &gt;= 0) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  print(&#x27;In Point.withAssert(): ($x, $y)&#x27;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 使用初始化列表设置 final 字段也非常方便</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">import &#x27;dart:math&#x27;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Point {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  final double x;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  final double y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  final double distanceFromOrigin;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Point(double x, double y)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      : x = x,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        y = y,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        distanceFromOrigin = sqrt(x * x + y * y);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="重定向构造函数"></a>重定向构造函数<a class="hash-link" href="#重定向构造函数" title="Direct link to heading">#</a></h3><p>有时候类中的构造函数仅用于调用类中其它的构造函数，此时该构造函数没有函数体，只需在函数签名后使用（<code>:</code>）指定需要重定向到的其它构造函数。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly dart"><div tabindex="0" class="prism-code language-dart codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Point {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  double x, y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // 该类的主构造函数</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Point(this.x, this.y);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // 委托实现给主构造函数</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Point.alongXAxis(double x) : this(x, 0);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="常量构造函数"></a>常量构造函数<a class="hash-link" href="#常量构造函数" title="Direct link to heading">#</a></h3><p>如果类生成的对象都是不变的，可以在生成这些对象时就将其变为编译时常量。可以在类的构造函数前加上 <code>const</code> 关键字并确保所有实例变量均为 <code>final</code> 来实现该功能。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly dart"><div tabindex="0" class="prism-code language-dart codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">class ImmutablePoint {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  static const ImmutablePoint origin = ImmutablePoint(0, 0);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // 未标记会报错: Error: Constructor is marked &#x27;const&#x27; so all fields must be final.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  final double x, y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  const ImmutablePoint(this.x, this.y);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>使用常量构造函数，在构造函数名之前加 <code>const</code> 关键字，来创建编译时常量时, 两个使用相同构造函数相同参数值构造的编译时常量是同一个对象。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly dart"><div tabindex="0" class="prism-code language-dart codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">var a = const ImmutablePoint(1, 1);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">var b = const ImmutablePoint(1, 1);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">assert(identical(a, b)); // 二者是同一个实例</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>在常量上下文场景中，通常可以省略掉构造函数或字面量前的 <code>const</code> 关键字。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly dart"><div tabindex="0" class="prism-code language-dart codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 这里有很多 const 关键字</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">const pointAndLine = const {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  &#x27;point&#x27;: const [const ImmutablePoint(0, 0)],</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  &#x27;line&#x27;: const [const ImmutablePoint(1, 10), const ImmutablePoint(-2, 11)],</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 只有从 Dart 2 开始才能根据上下文判断省略 const 关键字。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 根据上下文，可以只保留第一个 const 关键字，其余的全部省略</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 只需要一个 const 关键字，其它的则会隐式地根据上下文进行关联。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">const pointAndLine = {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  &#x27;point&#x27;: [ImmutablePoint(0, 0)],</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  &#x27;line&#x27;: [ImmutablePoint(1, 10), ImmutablePoint(-2, 11)],</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 但是如果无法根据上下文判断是否可以省略 const，则不能省略掉 const 关键字，否则将会创建一个 非常量对象</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">var a = const ImmutablePoint(1, 1); // 创建一个常量</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">var b = ImmutablePoint(1, 1); // 不会创建一个常量</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">assert(!identical(a, b)); // 这两变量并不相同</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="工厂构造函数"></a>工厂构造函数<a class="hash-link" href="#工厂构造函数" title="Direct link to heading">#</a></h3><blockquote><p>在工厂构造函数中无法访问 <code>this</code>。</p></blockquote><p>使用 <code>factory</code> 关键字标识类的构造函数将会令该构造函数变为工厂构造函数，这将意味着使用该构造函数构造类的实例时并非总是会返回新的实例对象。例如，工厂构造函数可能会从缓存中返回一个实例，或者返回一个子类型的实例。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly dart"><div tabindex="0" class="prism-code language-dart codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Logger 的工厂构造函数从缓存中返回对象，和 Logger.fromJson 工厂构造函数从 JSON 对象中初始化一个最终变量</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Logger {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  final String name;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  bool mute = false;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // _cache 变量是库私有的，因为在其名字前面有下划线。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  static final Map&lt;String, Logger&gt; _cache =</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &lt;String, Logger&gt;{};</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  factory Logger(String name) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return _cache.putIfAbsent(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        name, () =&gt; Logger._internal(name));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  factory Logger.fromJson(Map&lt;String, Object&gt; json) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return Logger(json[&#x27;name&#x27;].toString());</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Logger._internal(this.name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  void log(String msg) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (!mute) print(msg);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="方法"></a>方法<a class="hash-link" href="#方法" title="Direct link to heading">#</a></h2><p>方法是为对象提供行为的函数。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="实例方法"></a>实例方法<a class="hash-link" href="#实例方法" title="Direct link to heading">#</a></h3><p>对象的实例方法可以访问实例变量和 <code>this</code>。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly dart"><div tabindex="0" class="prism-code language-dart codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">import &#x27;dart:math&#x27;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">const double xOrigin = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">const double yOrigin = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Point {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  double x = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  double y = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Point(this.x, this.y);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  //  distanceTo() 方法是实例方法</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  double distanceTo(Point other) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    var dx = x - other.x;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    var dy = y - other.y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return sqrt(dx * dx + dy * dy);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="操作符"></a>操作符<a class="hash-link" href="#操作符" title="Direct link to heading">#</a></h3><p>运算符是有着特殊名称的实例方法。 <code>Dart</code> 允许使用以下名称定义运算符</p><ul><li><code>&lt;</code></li><li><code>+</code></li><li><code>|</code></li><li><code>[]</code></li><li><code>&gt;</code></li><li><code>/</code></li><li><code>^</code></li><li><code>[]=</code></li><li><code>&lt;=</code></li><li><code>~/</code></li><li><code>&amp;</code></li><li><code>~</code></li><li><code>&gt;=</code></li><li><code>*</code></li><li><code>&lt;&lt;</code></li><li><code>==</code></li><li><code>–</code></li><li><code>%</code></li><li><code>&gt;&gt;</code></li></ul><p>使用 <code>operator</code> 标识符表示重写操作符。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly dart"><div tabindex="0" class="prism-code language-dart codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 重写 + 和 - 操作符的例子</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Vector {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  final int x, y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Vector(this.x, this.y);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Vector operator +(Vector v) =&gt; Vector(x + v.x, y + v.y);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Vector operator -(Vector v) =&gt; Vector(x - v.x, y - v.y);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  @override bool operator ==(v) =&gt; v is Vector &amp;&amp; (this.x == v.x &amp;&amp; this.y == v.y);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  @override int get hashCode =&gt; this.x.hashCode + this.y.hashCode;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">void main() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  final v = Vector(2, 3);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  final w = Vector(2, 2);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  assert(v + w == Vector(4, 5));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  assert(v - w == Vector(0, 1));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="getter-和-setter"></a>Getter 和 Setter<a class="hash-link" href="#getter-和-setter" title="Direct link to heading">#</a></h3><p><code>Getter</code> 和 <code>Setter</code> 是一对用来读写对象属性的特殊方法，上面说过实例对象的每一个属性都有一个隐式的 <code>Getter</code> 方法，如果为非 <code>final</code> 属性的话还会有一个 <code>Setter</code> 方法，可以使用 <code>get</code> 和 <code>set</code> 关键字为额外的属性添加 <code>Getter</code> 和 <code>Setter</code> 方法。</p><p>使用 <code>Getter</code> 和 <code>Setter</code> 的好处是，可以先使用实例变量，过一段时间过再将它们包裹成方法且不需要改动任何代码，即先定义后更改且不影响原有逻辑。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly dart"><div tabindex="0" class="prism-code language-dart codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Rectangle {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  double left, top, width, height;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Rectangle(this.left, this.top, this.width, this.height);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // 定义两个计算产生的属性：right 和 bottom。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  double get right =&gt; left + width;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  set right(double value) =&gt; left = value - width;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  double get bottom =&gt; top + height;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  set bottom(double value) =&gt; top = value - height;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">void main() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  var rect = Rectangle(3, 4, 20, 15);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  assert(rect.left == 3);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  rect.right = 12;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  assert(rect.left == -8);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="抽象方法"></a>抽象方法<a class="hash-link" href="#抽象方法" title="Direct link to heading">#</a></h3><p><code>实例方法</code>、<code>Getter</code> 方法以及 <code>Setter</code> 方法都可以是抽象的，定义一个接口方法而不去做具体的实现让实现它的类去实现该方法，抽象方法只能存在于抽象类中。直接使用分号（<code>;</code>）替代方法体即可声明一个抽象方法。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly dart"><div tabindex="0" class="prism-code language-dart codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">abstract class Doer {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // 定义实例变量和方法等等</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  void doSomething(); // 定义一个抽象方法</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class EffectiveDoer extends Doer {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  void doSomething() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    // 提供一个实现，所以在这里该方法不再是抽象的……</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="抽象类"></a>抽象类<a class="hash-link" href="#抽象类" title="Direct link to heading">#</a></h2><p>使用关键字 <code>abstract</code> 标识类可以让该类成为抽象类，抽象类将无法被实例化。抽象类常常会包含抽象方法。
抽象类常用于声明接口方法、有时也会有具体的方法实现。如果想让抽象类同时可被实例化，可以为其定义工厂构造函数。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly dart"><div tabindex="0" class="prism-code language-dart codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 该类被声明为抽象的，因此不能被实例化。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">abstract class AbstractContainer {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // 定义构造函数、字段、方法等</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  void updateChildren(); // 抽象方法。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="隐式接口"></a>隐式接口<a class="hash-link" href="#隐式接口" title="Direct link to heading">#</a></h2><blockquote><p>如果需要实现多个类接口，可以使用逗号分割每个接口类：<code>class Point implements Comparable, Location {...}</code></p></blockquote><p>每一个类都隐式地定义了一个接口并实现了该接口，这个接口包含所有这个类的实例成员以及这个类所实现的其它接口。
如果想要创建一个 <code>A</code> 类支持调用 <code>B</code> 类的 API 且不想继承 <code>B</code> 类，则可以实现 <code>B</code> 类的接口。</p><p>一个类可以通过关键字 <code>implements</code> 来实现一个或多个接口并实现每个接口定义的 API：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly dart"><div tabindex="0" class="prism-code language-dart codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Person 类的隐式接口中包含 greet() 方法。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Person {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // _name 变量同样包含在接口中，但它只是库内可见的。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  final _name;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // 构造函数不在接口中。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Person(this._name);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // greet() 方法在接口中。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  String greet(String who) =&gt; &#x27;你好，$who。我是$_name。&#x27;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Person 接口的一个实现。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Impostor implements Person {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  get _name =&gt; &#x27;&#x27;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  String greet(String who) =&gt; &#x27;你好$who。你知道我是谁吗？&#x27;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">String greetBob(Person person) =&gt; person.greet(&#x27;小芳&#x27;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">void main() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  print(greetBob(Person(&#x27;小芸&#x27;)));  // 你好，小芳。我是小芸。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  print(greetBob(Impostor()));     // 你好小芳。你知道我是谁吗？</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="拓展类"></a>拓展类<a class="hash-link" href="#拓展类" title="Direct link to heading">#</a></h2><p>使用 <code>extends</code> 关键字来创建一个子类，并可使用 <code>super</code> 关键字引用一个父类。</p><p>子类可以重写父类的实例方法（包括 操作符）、 <code>Getter</code> 以及 <code>Setter</code> 方法。可以使用 @override 注解来表示重写了一个成员。</p><blockquote><p>如果重写 <code>==</code> 操作符，必须同时重写对象 <code>hashCode</code> 的 <code>Getter</code> 方法。</p></blockquote><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly dart"><div tabindex="0" class="prism-code language-dart codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Television {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  void turnOn() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    print(&quot;turnOn Television&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class SmartTelevision extends Television {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  @override void turnOn() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    print(&quot;turnOn SmartTelevision&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">void main() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  var smartTv = SmartTelevision();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  smartTv.turnOn();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="covariant-类型约束"></a>covariant 类型约束<a class="hash-link" href="#covariant-类型约束" title="Direct link to heading">#</a></h3><p>在重写时，可以使用 <a href="https://dart.cn/guides/language/sound-problems#the-covariant-keyword" target="_blank" rel="noopener noreferrer">covariant</a> 关键字来缩小代码中那些符合的方法参数或实例变量的类型。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly dart"><div tabindex="0" class="prism-code language-dart codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Animal {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  void chase(Animal x) { }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Mouse extends Animal { }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Cat extends Animal {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  @override</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  void chase(covariant Mouse x) { }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="nosuchmethod-方法"></a>noSuchMethod 方法<a class="hash-link" href="#nosuchmethod-方法" title="Direct link to heading">#</a></h3><p>如果调用了对象上不存在的方法或实例变量将会触发 <code>noSuchMethod</code> 方法，可以重写 noSuchMethod 方法来追踪和记录这一行为。声明的变量需要是 <code>dynamic</code> 类型的才可以触发。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly dart"><div tabindex="0" class="prism-code language-dart codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">class A {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // 除非重写 noSuchMethod，否则调用一个不存在的成员会导致 NoSuchMethodError。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  @override</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  void noSuchMethod(Invocation invocation) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    print(&#x27;你尝试使用一个不存在的成员：&#x27; + &#x27;${invocation.memberName}&#x27;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="扩展方法"></a>扩展方法<a class="hash-link" href="#扩展方法" title="Direct link to heading">#</a></h2><p>扩展方法是向现有库添加功能的一种方式。扩展方法不仅可以定义方法，还可以定义其他成员，例如 <code>getter</code>，<code>setter</code> 和<code>operator</code>。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly dart"><div tabindex="0" class="prism-code language-dart codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 定义一个拓展名为: NumberParsing</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 该拓展在 String 类上进行拓展，增加了 parserInt 方法</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">extension NumberParsing on String {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int parserInt() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return int.parse(this);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">void main() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  var n = &quot;233&quot;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  var x = n.parserInt();  // int: 233</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>以下是使用对字符串进行操作的扩展（名为 NumberParsing）来实现扩展方法 parseInt（）的方法：</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="类变量和方法"></a>类变量和方法<a class="hash-link" href="#类变量和方法" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="静态变量"></a>静态变量<a class="hash-link" href="#静态变量" title="Direct link to heading">#</a></h3><blockquote><p>静态变量在其首次被使用的时候才被初始化。</p></blockquote><p>使用关键字 <code>static</code> 可以声明类变量或类方法。静态变量（即类变量）常用于声明类范围内所属的状态变量和常量。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly dart"><div tabindex="0" class="prism-code language-dart codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Queue {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  static const initialCapacity = 16;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">void main() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  assert(Queue.initialCapacity == 16);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="静态方法"></a>静态方法<a class="hash-link" href="#静态方法" title="Direct link to heading">#</a></h3><blockquote><p>可以将静态方法作为编译时常量。例如，可以将静态方法作为一个参数传递给一个常量构造函数。</p></blockquote><p>静态方法（即类方法）不能对实例进行操作，因此不能使用 <code>this</code>。但是可以访问静态变量。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly dart"><div tabindex="0" class="prism-code language-dart codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">import &#x27;dart:math&#x27;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Point {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  double x, y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Point(this.x, this.y);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  static double distanceBetween(Point a, Point b) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    var dx = a.x - b.x;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    var dy = a.y - b.y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return sqrt(dx * dx + dy * dy);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">void main() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  var a = Point(2, 2);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  var b = Point(4, 4);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  var distance = Point.distanceBetween(a, b);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  assert(2.8 &lt; distance &amp;&amp; distance &lt; 2.9);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  print(distance);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="可调用类"></a>可调用类<a class="hash-link" href="#可调用类" title="Direct link to heading">#</a></h2><p>通过实现类的 <code>call()</code> 方法，允许使用类似函数调用的方式来使用该类的实例。</p><p>在下面的示例中，<code>WannabeFunction</code> 类定义了一个 <code>call()</code> 函数，函数接受三个字符串参数，函数体将三个字符串拼接，字符串间用空格分割，并在结尾附加了一个感叹号。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly dart"><div tabindex="0" class="prism-code language-dart codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">class WannabeFunction {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  String call(String a, String b, String c) =&gt; &#x27;$a $b $c!&#x27;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">var wf = WannabeFunction();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">var out = wf(&#x27;Hi&#x27;, &#x27;there,&#x27;, &#x27;gang&#x27;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">main() =&gt; print(out);</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div></div></article><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/dart/dart-tour-exceptions"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« Dart tour: 8、异常</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/dart/dart-tour-enums"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Dart tour: 10、枚举 »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#类的成员" class="table-of-contents__link">类的成员</a></li><li><a href="#实例变量" class="table-of-contents__link">实例变量</a></li><li><a href="#构造函数" class="table-of-contents__link">构造函数</a><ul><li><a href="#默认构造函数" class="table-of-contents__link">默认构造函数</a></li><li><a href="#构造函数不被继承" class="table-of-contents__link">构造函数不被继承</a></li><li><a href="#命名式构造函数" class="table-of-contents__link">命名式构造函数</a></li><li><a href="#调用父类非默认构造函数" class="table-of-contents__link">调用父类非默认构造函数</a></li><li><a href="#初始化列表" class="table-of-contents__link">初始化列表</a></li><li><a href="#重定向构造函数" class="table-of-contents__link">重定向构造函数</a></li><li><a href="#常量构造函数" class="table-of-contents__link">常量构造函数</a></li><li><a href="#工厂构造函数" class="table-of-contents__link">工厂构造函数</a></li></ul></li><li><a href="#方法" class="table-of-contents__link">方法</a><ul><li><a href="#实例方法" class="table-of-contents__link">实例方法</a></li><li><a href="#操作符" class="table-of-contents__link">操作符</a></li><li><a href="#getter-和-setter" class="table-of-contents__link">Getter 和 Setter</a></li><li><a href="#抽象方法" class="table-of-contents__link">抽象方法</a></li></ul></li><li><a href="#抽象类" class="table-of-contents__link">抽象类</a></li><li><a href="#隐式接口" class="table-of-contents__link">隐式接口</a></li><li><a href="#拓展类" class="table-of-contents__link">拓展类</a><ul><li><a href="#covariant-类型约束" class="table-of-contents__link">covariant 类型约束</a></li><li><a href="#nosuchmethod-方法" class="table-of-contents__link">noSuchMethod 方法</a></li></ul></li><li><a href="#扩展方法" class="table-of-contents__link">扩展方法</a></li><li><a href="#类变量和方法" class="table-of-contents__link">类变量和方法</a><ul><li><a href="#静态变量" class="table-of-contents__link">静态变量</a></li><li><a href="#静态方法" class="table-of-contents__link">静态方法</a></li></ul></li><li><a href="#可调用类" class="table-of-contents__link">可调用类</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.d5afd100.js"></script>
<script src="/assets/js/main.c75862fc.js"></script>
</body>
</html>